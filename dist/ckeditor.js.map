{"version":3,"sources":["webpack://CKEditor/webpack/universalModuleDefinition","webpack://CKEditor/external umd {\"commonjs\":\"vue\",\"commonjs2\":\"vue\",\"amd\":\"vue\",\"root\":\"Vue\"}","webpack://CKEditor/webpack/bootstrap","webpack://CKEditor/webpack/runtime/define property getters","webpack://CKEditor/webpack/runtime/hasOwnProperty shorthand","webpack://CKEditor/./src/ckeditor.js","webpack://CKEditor/./src/plugin.js"],"names":["root","factory","exports","module","require","define","amd","self","__WEBPACK_EXTERNAL_MODULE__976__","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","d","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","name","created","CKEDITOR_VERSION","window","major","split","map","Number","console","warn","render","h","this","tagName","props","editor","type","Function","default","config","String","disabled","Boolean","data","instance","lastEditorData","mounted","editorConfig","assign","create","$el","then","markRaw","setUpEditorEvents","enableReadOnlyMode","$emit","catch","error","beforeUnmount","destroy","watch","readOnlyMode","disableReadOnlyMode","methods","editing","view","document","on","evt","Vue","version","getVueVersion","i","parseInt","Error","install","app","component","CKEditorComponent"],"mappings":";;;;CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,EAAQG,QAAQ,QACR,mBAAXC,QAAyBA,OAAOC,IAC9CD,OAAO,CAAC,OAAQJ,GACU,iBAAZC,QACdA,QAAkB,SAAID,EAAQG,QAAQ,QAEtCJ,EAAe,SAAIC,EAAQD,EAAU,KARvC,CASGO,KAAOC,GACV,M,4BCVAL,EAAOD,QAAUM,ICCbC,EAA2B,GAG/B,SAASC,EAAoBC,GAE5B,IAAIC,EAAeH,EAAyBE,GAC5C,QAAqBE,IAAjBD,EACH,OAAOA,EAAaV,QAGrB,IAAIC,EAASM,EAAyBE,GAAY,CAGjDT,QAAS,IAOV,OAHAY,EAAoBH,GAAUR,EAAQA,EAAOD,QAASQ,GAG/CP,EAAOD,QCpBfQ,EAAoBK,EAAI,CAACb,EAASc,KACjC,IAAI,IAAIC,KAAOD,EACXN,EAAoBQ,EAAEF,EAAYC,KAASP,EAAoBQ,EAAEhB,EAASe,IAC5EE,OAAOC,eAAelB,EAASe,EAAK,CAAEI,YAAY,EAAMC,IAAKN,EAAWC,MCJ3EP,EAAoBQ,EAAI,CAACK,EAAKC,IAAUL,OAAOM,UAAUC,eAAeC,KAAKJ,EAAKC,G,yDCUlF,MAGA,GACCI,KAAM,WAENC,UACC,MAAM,iBAAEC,GAAqBC,OAK7B,GAAKD,EAAmB,CACvB,MAAQE,GAAUF,EAAiBG,MAAO,KAAMC,IAAKC,QAEhDH,EAAQ,IACZI,QAAQC,KAAM,oFAGfD,QAAQC,KAAM,8DAIhBC,SACC,OAAOC,OAAGC,KAAKC,UAQhBC,MAAO,CACNC,OAAQ,CACPC,KAAMC,SACNC,QAAS,MAMVC,OAAQ,CACPH,KAAMzB,OACN2B,QAAS,KAAM,KAEhBL,QAAS,CACRG,KAAMI,OACNF,QAAS,OAEVG,SAAU,CACTL,KAAMM,QACNJ,SAAS,IAIXK,KAAI,KACI,CAGNC,SAAU,KAEVC,eAAgB,CACfT,KAAMI,OACNF,QAAS,MAKZQ,UAGC,MAAMC,EAAepC,OAAOqC,OAAQ,GAAIhB,KAAKO,QAM7CP,KAAKG,OAAOc,OAAQjB,KAAKkB,IAAKH,GAC5BI,KAAMhB,IAENH,KAAKY,UAAWQ,aAASjB,GAEzBH,KAAKqB,oBASArB,KAAKS,UACTN,EAAOmB,mBA5FqB,sBAgG7BtB,KAAKuB,MAAO,QAASpB,KAErBqB,MAAOC,IACP7B,QAAQ6B,MAAOA,MAIlBC,gBACM1B,KAAKY,WACTZ,KAAKY,SAASe,UACd3B,KAAKY,SAAW,MAKjBZ,KAAKuB,MAAO,UAAWvB,KAAKY,WAG7BgB,MAAO,CA8BNnB,SAAUoB,GACJA,EACJ7B,KAAKY,SAASU,mBAlJe,sBAoJ7BtB,KAAKY,SAASkB,oBApJe,wBAyJhCC,QAAS,CACRV,oBACC,MAAMlB,EAASH,KAAKY,SAuBpBT,EAAO6B,QAAQC,KAAKC,SAASC,GAAI,QAASC,IACzCpC,KAAKuB,MAAO,QAASa,EAAKjC,KAG3BA,EAAO6B,QAAQC,KAAKC,SAASC,GAAI,OAAQC,IACxCpC,KAAKuB,MAAO,OAAQa,EAAKjC,SCxLrBX,GA0BR,WAEC,GAAK6C,UACJ,OAAOA,UAOR,GAAKA,EAAgB,QACpB,OAAOA,EAAgB,QAAGC,QArCVC,GAAgB9C,MAAO,KAAMC,IAAK8C,GAAKC,SAAUD,EAAG,KAGtE,GAAKhD,EAAQ,EACZ,MAAM,IAAIkD,MACT,mLAMF,MAYA,EAZiB,CAMhBC,QAASC,GACRA,EAAIC,UAAW,WAAYC,IAE5BD,UAAWC,I,gBNnBZ","file":"ckeditor.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"vue\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"vue\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"CKEditor\"] = factory(require(\"vue\"));\n\telse\n\t\troot[\"CKEditor\"] = factory(root[\"Vue\"]);\n})(self, (__WEBPACK_EXTERNAL_MODULE__976__) => {\nreturn ","module.exports = __WEBPACK_EXTERNAL_MODULE__976__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/* global window, console */\n\nimport { h, markRaw } from 'vue';\n// import { debounce } from 'lodash-es';\n\nconst SAMPLE_READ_ONLY_LOCK_ID = 'Integration Sample';\n// const INPUT_EVENT_DEBOUNCE_WAIT = 300;\n\nexport default {\n\tname: 'ckeditor',\n\n\tcreated() {\n\t\tconst { CKEDITOR_VERSION } = window;\n\n\t\t// Starting from v34.0.0, CKEditor 5 introduces a lock mechanism enabling/disabling the read-only mode.\n\t\t// As it is a breaking change between major releases of the integration, the component requires using\n\t\t// CKEditor 5 in version 34 or higher.\n\t\tif ( CKEDITOR_VERSION ) {\n\t\t\tconst [ major ] = CKEDITOR_VERSION.split( '.' ).map( Number );\n\n\t\t\tif ( major < 34 ) {\n\t\t\t\tconsole.warn( 'The <CKEditor> component requires using CKEditor 5 in version 34 or higher.' );\n\t\t\t}\n\t\t} else {\n\t\t\tconsole.warn( 'Cannot find the \"CKEDITOR_VERSION\" in the \"window\" scope.' );\n\t\t}\n\t},\n\n\trender() {\n\t\treturn h( this.tagName );\n\t},\n\n\t// model: {\n\t// \tprop: 'modelValue',\n\t// \tevent: 'update:modelValue'\n\t// },\n\n\tprops: {\n\t\teditor: {\n\t\t\ttype: Function,\n\t\t\tdefault: null\n\t\t},\n\t\t// modelValue: {\n\t\t// \ttype: String,\n\t\t// \tdefault: ''\n\t\t// },\n\t\tconfig: {\n\t\t\ttype: Object,\n\t\t\tdefault: () => ( {} )\n\t\t},\n\t\ttagName: {\n\t\t\ttype: String,\n\t\t\tdefault: 'div'\n\t\t},\n\t\tdisabled: {\n\t\t\ttype: Boolean,\n\t\t\tdefault: false\n\t\t}\n\t},\n\n\tdata() {\n\t\treturn {\n\t\t\t// Don't define it in #props because it produces a warning.\n\t\t\t// https://v3.vuejs.org/guide/component-props.html#one-way-data-flow\n\t\t\tinstance: null,\n\n\t\t\tlastEditorData: {\n\t\t\t\ttype: String,\n\t\t\t\tdefault: ''\n\t\t\t}\n\t\t};\n\t},\n\n\tmounted() {\n\t\t// Clone the config first so it never gets mutated (across multiple editor instances).\n\t\t// https://github.com/ckeditor/ckeditor5-vue/issues/101\n\t\tconst editorConfig = Object.assign( {}, this.config );\n\n\t\t// if ( this.modelValue ) {\n\t\t// \teditorConfig.initialData = this.modelValue;\n\t\t// }\n\n\t\tthis.editor.create( this.$el, editorConfig )\n\t\t\t.then( editor => {\n\t\t\t\t// Save the reference to the instance for further use.\n\t\t\t\tthis.instance = markRaw( editor );\n\n\t\t\t\tthis.setUpEditorEvents();\n\n\t\t\t\t// Synchronize the editor content. The #modelValue may change while the editor is being created, so the editor content has\n\t\t\t\t// to be synchronized with these potential changes as soon as it is ready.\n\t\t\t\t// if ( this.modelValue !== editorConfig.initialData ) {\n\t\t\t\t// \teditor.setData( this.modelValue );\n\t\t\t\t// }\n\n\t\t\t\t// Set initial disabled state.\n\t\t\t\tif ( this.disabled ) {\n\t\t\t\t\teditor.enableReadOnlyMode( SAMPLE_READ_ONLY_LOCK_ID );\n\t\t\t\t}\n\n\t\t\t\t// Let the world know the editor is ready.\n\t\t\t\tthis.$emit( 'ready', editor );\n\t\t\t} )\n\t\t\t.catch( error => {\n\t\t\t\tconsole.error( error );\n\t\t\t} );\n\t},\n\n\tbeforeUnmount() {\n\t\tif ( this.instance ) {\n\t\t\tthis.instance.destroy();\n\t\t\tthis.instance = null;\n\t\t}\n\n\t\t// Note: By the time the editor is destroyed (promise resolved, editor#destroy fired)\n\t\t// the Vue component will not be able to emit any longer. So emitting #destroy a bit earlier.\n\t\tthis.$emit( 'destroy', this.instance );\n\t},\n\n\twatch: {\n\t\t// modelValue( value ) {\n\t\t// Synchronize changes of #modelValue. There are two sources of changes:\n\t\t//\n\t\t//                External modelValue change      ──────╮\n\t\t//                                                      ╰─────> ┏━━━━━━━━━━━┓\n\t\t//                                                              ┃ Component ┃\n\t\t//                                                      ╭─────> ┗━━━━━━━━━━━┛\n\t\t//                   Internal data change         ──────╯\n\t\t//             (typing, commands, collaboration)\n\t\t//\n\t\t// Case 1: If the change was external (via props), the editor data must be synced with\n\t\t// the component using instance#setData() and it is OK to destroy the selection.\n\t\t//\n\t\t// Case 2: If the change is the result of internal data change, the #modelValue is the\n\t\t// same as this.lastEditorData, which has been cached on #change:data. If we called\n\t\t// instance#setData() at this point, that would demolish the selection.\n\t\t//\n\t\t// To limit the number of instance#setData() which is time-consuming when there is a\n\t\t// lot of data we make sure:\n\t\t//    * the new modelValue is at least different than the old modelValue (Case 1.)\n\t\t//    * the new modelValue is different than the last internal instance state (Case 2.)\n\t\t//\n\t\t// See: https://github.com/ckeditor/ckeditor5-vue/issues/42.\n\t\t// \tif ( this.instance && value !== this.lastEditorData ) {\n\t\t// \t\tthis.instance.setData( value );\n\t\t// \t}\n\t\t// },\n\n\t\t// Synchronize changes of #disabled.\n\t\tdisabled( readOnlyMode ) {\n\t\t\tif ( readOnlyMode ) {\n\t\t\t\tthis.instance.enableReadOnlyMode( SAMPLE_READ_ONLY_LOCK_ID );\n\t\t\t} else {\n\t\t\t\tthis.instance.disableReadOnlyMode( SAMPLE_READ_ONLY_LOCK_ID );\n\t\t\t}\n\t\t}\n\t},\n\n\tmethods: {\n\t\tsetUpEditorEvents() {\n\t\t\tconst editor = this.instance;\n\n\t\t\t// Use the leading edge so the first event in the series is emitted immediately.\n\t\t\t// Failing to do so leads to race conditions, for instance, when the component modelValue\n\t\t\t// is set twice in a time span shorter than the debounce time.\n\t\t\t// See https://github.com/ckeditor/ckeditor5-vue/issues/149.\n\t\t\t// const emitDebouncedInputEvent = debounce( evt => {\n\t\t\t// Cache the last editor data. This kind of data is a result of typing,\n\t\t\t// editor command execution, collaborative changes to the document, etc.\n\t\t\t// This data is compared when the component modelValue changes in a 2-way binding.\n\t\t\t// const data = this.lastEditorData = editor.getData();\n\n\t\t\t// The compatibility with the v-model and general Vue.js concept of input–like components.\n\t\t\t// \tthis.$emit( 'update:modelValue', data, evt, editor );\n\t\t\t// \tthis.$emit( 'input', data, evt, editor );\n\t\t\t// }, INPUT_EVENT_DEBOUNCE_WAIT, { leading: true } );\n\n\t\t\t// Debounce emitting the #input event. When data is huge, instance#getData()\n\t\t\t// takes a lot of time to execute on every single key press and ruins the UX.\n\t\t\t//\n\t\t\t// See: https://github.com/ckeditor/ckeditor5-vue/issues/42\n\t\t\t// editor.model.document.on( 'change:data', emitDebouncedInputEvent );\n\n\t\t\teditor.editing.view.document.on( 'focus', evt => {\n\t\t\t\tthis.$emit( 'focus', evt, editor );\n\t\t\t} );\n\n\t\t\teditor.editing.view.document.on( 'blur', evt => {\n\t\t\t\tthis.$emit( 'blur', evt, editor );\n\t\t\t} );\n\t\t}\n\t}\n};\n","/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/* eslint-env browser */\nimport * as Vue from 'vue';\nimport CKEditorComponent from './ckeditor.js';\n\nconst [ major ] = getVueVersion().split( '.' ).map( i => parseInt( i, 10 ) );\n\n/* istanbul ignore if */\nif ( major < 3 ) {\n\tthrow new Error(\n\t\t'The CKEditor plugin works only with Vue 3+. ' +\n\t\t'For more information, please refer to ' +\n\t\t'https://ckeditor.com/docs/ckeditor5/latest/builds/guides/integration/frameworks/vuejs-v3.html'\n\t);\n}\n\nconst CKEditor = {\n\t/**\n\t * Installs the plugin, registering the `<ckeditor>` component.\n\t *\n\t * @param {Vue} app The application instance.\n\t */\n\tinstall( app ) {\n\t\tapp.component( 'ckeditor', CKEditorComponent );\n\t},\n\tcomponent: CKEditorComponent\n};\n\nexport default CKEditor;\n\n/* istanbul ignore next */\nfunction getVueVersion() {\n\t// Vue 3+.\n\tif ( Vue.version ) {\n\t\treturn Vue.version;\n\t}\n\n\t// Webpack complains if the `Vue.default` does not exist. It is exported by Vue 2.\n\t// export 'default' (imported as 'Vue') was not found in 'vue'\n\tconst DEFAULT_KEY = 'default';\n\n\tif ( Vue[ DEFAULT_KEY ] ) {\n\t\treturn Vue[ DEFAULT_KEY ].version;\n\t}\n}\n"],"sourceRoot":""}